# Java内存区域
## 内存区域
### 线程私有
* 程序计数器
    * 作用
        * 字节码解释器通过程序计数器来依次读取指令，实现代码流程控制
        * 多线程场景下，记录当前线程执行位置，用于线程切换
    * 不会出现 OutMemoryException
* 虚拟机栈
    * 一般说的堆栈中的栈， 描述Java方法运行的内存模型
    * 由栈帧组成
        * 局部变量表
        * 操作数栈
        * 动态链接
        * 方法出口信息
    * 异常
        * OutOfMemoryException
        * StackOverFlowException
* 本地方法栈
    * 与虚拟机类似， 为本地方法的调用服务， hotpot 中与 虚拟机栈合并了
### 线程共有
* 堆
    * 虚拟机管理的最大一块内存
    * 唯一目的： 存放对象
    * GC的主要区域
    * 分代
        * 新生代 Young Generation
            * Eden
            * S1(from survivor)
            * S2(to survivor)
        * 老年代 Old Generation
        * 永久代  Perm
        * 概要: Java 程序可以使用的堆空间
        * 概要: java1.8 中使用 无空间代替， 元空间不占堆内存，直接使用物理内存
* 方法区 Non-Heap
    * 存储jvm加载的类信息，常量，静态变量， 即时编译后的代码等
    * 运行时常量池
        * 方法区的一部分
        * jdk1.7 后， 从方法区移到了堆中
        * 包含的内容
            * 字面量
                * 文本字符串
                * final 常量值
                * 基本数据类型的值
                * 其它
            * 符号引用
                * 类和结构的完全限定名
                * 字段名称和描述符
                * 方法名称和描述符
### 直接内存
* 不是虚拟机运行时数据区域的一部分
* 只受物理内存大小的限制
* 通过 DirectByteBuffer  引用这块内存
## HotSpot
### 对象创建的过程
* 1. 类加载检查
    * jvm 遇到 new 指令时， 首先检查能否在常量池中定位的类的符号引用，并检查符号引用代表的类是否加载解析初始化过。如果没有，先执行类加载过程
* 2. 分配内存
    * 类加载完成后就可以确定一个类对象的大小
    * 分配方式
        * 指针碰撞
            * 堆内存规整（没有内存碎片）的情况下
            * 原理： 用过的内存整合到一边，没用过的放另一边，中间有一个分界指针， 向没用过的内存方向将指针移动对象大小即可
            * GC收集器： Serial, ParNew
        * 空闲列表
            * 堆内存不规整的情况下
            * 原理： JVM 维护一个列表， 记录哪些内存块可用， 分配时找一块足够大的内存块为对象分配内存，并更新列表
            * GC收集器： CMS
    * 内存分配的并发问题
        * CAS+失败重试
        * TLAB
* 3. 初始化零值
    * 除对象头外， 将分配到的内存空间都初始化为零值。
* 4. 设置对象头
    * 为对象设置必要的信息
        * 类， 类的元信息的位置， 对象Hash， GC年龄等
* 5. 执行 init方法
    * 从JVM视角来看，上面工作完成后一个对象已经产生；但从Java程序的视角看，对象创建才刚开始， 执行init， 按程序员的意愿进行初始化
### 对象的内存布局
* 对象头
    * 对象自身运行时数据
    * 类型指针
* 实例数据
* 对齐填充
    * HotSpot 要求对象大小需要是8字节的整数倍， 如果实际大小不是8字节整数倍，就需要填充
### 对象的访问定位
* 使用句柄
* 直接指针

*XMind: ZEN - Trial Version*