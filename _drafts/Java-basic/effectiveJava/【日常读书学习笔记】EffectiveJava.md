【日常读书学习笔记】EffectiveJava

# 创建和销毁对象
1. 考虑用表态工厂方法代替构造器
2. 有多个构造器参数时，考虑使用构建器
3. 使用私有构造器或枚举类型来强化Singleton
4. 通过私有构造口器来强化不可实例化的能力
5. 避免创建不必要的对象 
6. 消除过期的引用
7. 避免使用终结方法

# 对所有对象都通用的方法
8. 覆盖 equals 时遵守通用约定
9. 覆盖 equals 时始终要覆盖 hashCode
10. 始终要覆盖 toString
11. 谨慎覆盖 clone
12. 考虑实现 Comparable 接口
13. 类和成员的可访问性最小化

# 类和接口
14. 公有类中使用公有方法而非仅有域
15. 可变性最小化
16. 复合优先于继承
17. 要么为继承而设计且有文档，要么就禁止继承
18. 接口优先于抽象类
19. 接口只用于定义类型
20. 类层次优于标签类
21. 用函数对象表示策略
22. 优先考虑静态成员类

# 泛型
23. 不要在新代码中使用原生态类型
24. 消除非受检警告
25. 列表优先于数组
26. 优先考虑泛型
27. 优先考虑泛型方法
28. 利用有限制通配符提升API的灵活性
29. 优先考虑类型安全的异构容器

# 枚举和注解
30. 用enum代替int 常量
31. 用实例域代替序数
32. 用 enumSet 代替位域
33. 用 enumMap 代替序数索引
34. 用接口模拟可伸缩的枚举
35. 注解优先于全名模式
36. 坚持使用 override 注解
37. 用标记接口定义类型

# 方法
38. 检查参数的有效性
39. 必要时进行保护性拷贝
40. 谨慎设计方法签名
41. 慎用重载
42. 慎用可变参数
43. 返回零长度的数组或集合，而非null
44. 为所有导出的API元素编写文档和注释

# 通用程序设计
45. 局部变量的作用域最小化
46. for-each 优先于 fori
47. 了解和使用类库
48. 精确计算避免使用 float, double
49. 基本类型优于装箱基本类型
50. 若其它类型更合适，则避免使用字符串
51. 当心字符串连接的性能
52. 通过接口引用对象
53. 接口优先于反射机制
54. 慎用本地方法
55. 遵守命名惯例
56. 谨慎优化

# 异常
57. 只针对异常情况使用异常
58. 可恢复的情况使用受检异常，编程错误使用非受检异常
59. 避免不必要的受检异常
60. 优先使用标准的异常
61. 抛出与抽象对应的异常
62. 每个方法抛出的异常都要有文档
63. 在细节消息中包含能捕获失败的信息
64. 努力使失败保持原子性
65. 不要忽略异常

# 并发
66. 同步访问共享的可变数据
67. 避免过度同步
68. executor 和 task 优先于 线程
69. 并发工具优先于 wait notify
70. 线程安全性的文档化
71. 慎用延迟初始化
72. 不要依赖于线程调度器
73. 避免使用线程组

# 序列化

将一个对象编码为字节流叫作序列化(serializing)， 反之称为反序列化(deserializing)。


74. 谨慎地实现 Serializable 接口
    实现 Serializable 的代价
    - 一旦一类被被发布，就大大降低了“改变这个类的实现”的灵活性
    - 增加了Bug和安全漏洞的可能性
    - 随着新版本的发行，测试负担加重，需要测试兼容性

    一些益处
    - 一些框架依赖于序列化来实现对象的传输、持久化等，有必要实现 Serializable
    - 有一些组件要求一个类必需实现 Serializable

    根据经验
    - 如Date, BigInteger 等值类和大多数的集合类应该实现 Serializable
    - 表示活动实体的类，如线程池等，一般不应该实现 Serializable
    - 为了继承而设计的类尽可能少地去实现 Serializable
        + 例外有 Throwable， 为了方便异常的传输，是合适的
        + 通过提供一个protected的无参构造器作为折衷方案，允许子类实现Serializable
    - 内部类不应该实现Serializable
    - 静态成员类可以实现Serializable
75. 考虑使用自定义的序列化形式
76. 保护性地编写readObject方法
77. 对于实例控制，枚举类型优先于readResolve
78. 考虑使用序列化代理代替序列化实例

























