2018-09-28-Java并发编程


# 16 Java 内存模型
本书中，我们尽可能地避开了Java（JMM）内存模型人底层细节，而将重点放在一些高层设计问题，例如安全发布，同步策略的规范以及一致性等。它们的安全性都来自于JMM，并且当你理解了这些机制的工作原理后，就能更容易地使用它们。本章将介绍Java内存模型的底层需求以及所提供的保证，此外还将介绍在本书给出的一些高层设计原则背后的原理。

## 16.1 什么是内存模型，为什么需要它
    假设一个线程为变量aVariable赋值：
    aVariable = 3;

内存模型需要解决这个问题：“什么条件下，读取 aVariable 的线程将看到这个值为 3？”这听起来似乎是一个愚蠢的问题，但如果 缺少同步，那么将会有许多因素使得线程无法立即甚至永远，看到另一个线程的操作结果。在编译器中生成的指令顺序，可以与源代码中的顺序不同，此外编译器还会把变量保存在寄存器而不是内存中处理器可以采用乱序或并行等方式 来执行指令；缓存可能会改变将写入变量提交到主内存的次序；而且，保存在处理器本地缓存中的值，对于其他处理器是不可见的。这些因素都会使得一个线程无法看到变量的最新值，并且会导致其它线程中的内存操作似乎在乱序执行———— 如果没有使用正确的同步。

在单线程环境中， 我们无法看到所有这些底层技术，它们除了提高程序的执行速度外， 不会产生其它影响。Java语言规范要求JVM在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中的执行的结果 相同，那么上述所有操作都是允许的。这确实是一件好事情，因为在最近几年中，计算性能的提升在很大程度上要归功于这些重新排序措施。当然，时钟频率的提供同样提升了性能，此外还有不断提升的并行性-- 采用流水线的超标量执行单元，动态指令调度，猜测执行以及完备的多级缓存。随着处理变得越来越强大，编译器也在不断地改进：通过对指令重新排序来实现优化执行，以及使用成熟的全局寄存器分配算法。由于时钟频率越来越难以提高，因此许多处理器制造厂商都开始转而生产多核处理器，因为能够提高的只有硬件并行性。

在多线程环境中，维护程序的串行性将导致很大的性能开销。对于并发应用程序中的线程来说，它们在大部分时间里都执行各自的任务，因此在线程之间的协调操作只会降低应用程序的运行速度，而不会带来任务好处。只有当多个线程要共享数据时，才必须协调它们之间的操作，并且JVM依赖程序通过同步操作来找出这些协调操作将在何时发生。

JMMf规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其它线程可见。JMM在设计时就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能实现高性能的JVM。如果你不了解在现代处理器和编译器中使用的程序性能提升措施，那么在刚刚接触JMM的某些方面时会感到困惑。

### 16.1.1 平台的内存模型

在共享内存的多处理器体系架构中， 每个处理器都拥有自己的缓存，并且定期地与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性（Cache Coherence），其中一部分只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。操作系统、编译器以及运行时（有时甚至包括应用程序）需要弥合这种在硬件能力与线程安全需求之间的差异。

要想确保每个处理器都能在任意时刻知道其它处理器正在进行的工作，将需要非常大的开销。在大多数时间里，这种信息是不必要的，因此处理器会适当放宽存储一致性保证，以换取性能的提升。在架构定义 的内存模型中将告诉应用程序可以从内存系统中获得怎样的保证，些外还定义了一些特殊的指令（称为内存栅栏或栅栏），当需要共享数据时， 这些指令就能实现额外的存储协调保证。为了使Java开发人员无须关心不同架构上内存模型之间的差异，Java还提供了自己的内存模型。并且JVM通过在适当的位置上插入内存栅栏来屏蔽在JMM与底层平台内存模型之间的差异。

程序执行一种简单假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在体积处理器上执行，并且在每次 读取变量时，都 能获得在执行序列中（任何处理器）最近 一次写入该变量的值。这种乐观的模型就被称为串行一致性。软件开发人员经常会错误地假设存在串行一致性，但在任何一款现代多处理器架构中都不会提供这种串行一致性，JMM也是如此。冯诺伊曼模型这种经典的串行计算模型，只能近似描述现代多处理器的行为。

在现代支持共享内存的多处理器（和编译器）中，当跨线程共享数据时， 会出现一些奇怪的情况，除非通过使用内存栅栏防止这些情况的发生。幸运的是，Java程序不需要 


# 第2章 线程安全性
如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序应付出现错误。有有一种方式可以修复这个问题：
- 不在线程之间共享该状态变量。
- 将状态变量修改为不可变的变量。
- 在肩部状态变量时使用同步。

## 2.1 什么是线程安全性
线程安全性的定义中，最核心的概念就是正确性。
正确性的含义是，某个类的行为与其规范完全一致。
不变性条件来约束对象的状态， 各种后验条件来描述对象操作的结果。

在线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。

无状态对象一定是线程安全的。




## 2.2 原子性
### 2.2.1 竞态条件  race condition
正确的结果取决于运气
Check-Then-Act, 通过一个可能失效的观测结果来决定下一步的动作。

### 2.2.2 示例延迟初始化的竞态条件
竞态条件并不问题会产生错误，还需要某种不恰当的执行时序。

### 2.2.3 复合操作
lazyInitRace 和 UnsafeContionFactorizer 都包含一组需要以原子方式执行的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。

## 2.3 加锁机制
在线程安全性的定义中要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

###  2.3.1 内置锁
Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchroized Block）。
内置锁相当于一种互斥体（互斥锁）

###  2.3.2 重入
内置锁是可重入的。
重入意味着获取锁的操作的粒度是“线程”，而不是“调用”。

## 2.4 用锁保护状态
对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

## 2.5 活跃性与性能
通常，在简单性与性能之间存在着相互制约因素。当实现 某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）

当执行时间较长的计算或者可能 无法快速 完成的操作时（如I/O），一定不要持有锁。






