---
layout: post
title:  "谈谈对CAP的理解"
date:   2019-08-12 11:15:00 +0800
author: "HanYong"
tags:
        - 架构
---

# CAP的概念
我们说CAP是指在分布式/微服务的架构下提出的。 

- 一致性（Consistency） ： 
- 可用性（Availability） ： 
- 分区容错性（Partition tolerance） ： 

# 可以牺牲哪一个？
## 牺牲一致性
牺牲一致性不是说不要一致性了， 而是要实现最终一致性。  一般我们会说要实现一个最终一致性的AP系统。 

在分布式系统中实现一个强一致性的特性相对来说一个困难的工作。 实现方案有 XA、 2PC、 TCC。 
像阿里去年开源的fescar（现改名seata）就是一个不错的实现。  
如果从性能的角度考虑，强一致性一般会带来较大的影响，因为需要跨服务对资源进行协。  

而如果不强求强一致性，允许数据在相对短的时间内出现不一致，但能保证最终一致性，从实现和性能扩展的角度来看，实现起来都相对容易些。 

### 牺牲可用性
牺牲可用性就是说当数据处于不一致的状态时，或者有节点宕机时，整个服务系统不可用以保证数据不会出错。 


### 牺牲分区容错性
先说结论： 没有CA的分布式设计， P是分布式系统必须要保证的。  牺牲了分区容错性也就说一个分区出错，整个分布式系统不能工作， 也就是说分布式式系统其实是退化成了一个原始的单块系统。 


# AP 还是 CP？
一般来说，最终一致性的AP可能是一个更好的选择。  CP相对来说比较难以实现和扩展。 而且在业务上AP可能更容易接受。  大多数的业务场景上（偏查询类的） 一些暂时不一致的数据总比系统完全不可用更能让人接受。

但也不是说构建的单独服务一定要是一个纯AP或者是纯CP的服务。  
**可以将CAP的概念下沉到每个具体的功能上。**
怎么理解呢？ 举个例子， 像是一个账户的积分系统：  查看积分的功能不一定要强调强一致性，用户可以看到一个相对滞后的积分数量，只要能保证用户在一个可控的时间内可以看到自己正确的积分在业务上应该也是可以接受的，我们优化要保证的是功能可用。  但是对于使用积分进行抵扣的功能上，则必须要保证积分数据的一致性，用户不能使用的积分不能超出自己积分余额，宁可功能暂不可用也不能出现超用的现象。 甚至对于给用户发放积分的功能，我们也可以采用异步消息发放的方式（保证幂等性），因为一般给一个用户增加积分是一定可以成功的，可以优先保证上游调用端的可用性，对请求进行缓冲，后面异步处理。 据业务功能的不同性质，来选择是保证A还是保证C。 


# BASE

BASE是指 Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）。 

BASE 是CAP中 C与A相妥协的一个结果， 即， 如果不能保证数据的强一致性，则允许数据同步存在一定的延迟，在保证基本功能可用的情况下，让数据达到最终一致性。 