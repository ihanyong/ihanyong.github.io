---
layout: post
title:  "分布式事务两阶段提交（2PC）方案详解"
date:   2019-053-20 11:15:00 +0800
author: "HanYong"
tags:
        - 读书
        - 架构
        - 分布式事务
---

在分布式事务中， 2PC不算是一个最优的分布式解决方案，但是可以通过对2PC的深入学习来加深对分布式事务的理解。


# 原子性 & 分布式
一般对事务原子性的定义： 一个事务的结果要么是全部提交成功， 要么全部回滚。 不会出现部分成功部分失败的状态。 

在单节点数据库系统中，我们可能通过存储引擎来保证事务原子性。在应用程序用不需要过多考虑事务问题，数据库会管理事务的提交与回滚等。

但是在多个数据库节点上事务是怎样的呢？ 比如一个事务中需要更新的两张表分在两个数据库节点上， 或者主数据与数据的索引不在同一个节点上。  如果只是简单的向所有节点发送提交请求，各节点独立提交事务是不够的了。很容易就造成部分节点上提交成功而部分节点上提交失败，就破坏了原子性：
- 有些节点上可能会出现数据的冲突而提交失败，有些节点可以提交成功；
- 网络原因，提交事务的通知没有到达部分节点；
- 部分节点的磁盘故障，造成该节点上事务没有提交；而其它节点上提交成功；

在分布式的环境下，为保证一致性，所有节点上的事务要么一些成功，要么一起失败。和在单节点上的原子性要求是一样的。

# 2PC
两阶段提交（tow-phase commit）是一种保证多节点事务原子性的算法。即能确保事务在所有节点上一起成功或者一起失败。

![执行成功的2PC示意图](https://raw.githubusercontent.com/ihanyong/ihanyong.github.io/master/img/system/successful2pc.png)


2PC引入了一个新的角色，协调器（或者叫事务管理器）。协调器可以实现为一个运行在应用程序中的包，也可以是一个独立运行的服务。 2PC的事务开始于在多个数据库节点上读取并写入数据。这些数据库节点我们叫做事务的参与者。当应用程序准备提交事务时， 协调器发送一个 prepare 请求到每个参与者节点上，询问参与者是否可以提交（阶段1）。协调器会跟踪所有参与者的响应：
- 如果所有参与者回应“yes”， 表示所有事务参与者都准备好了提交。然后协调器就会开始阶段2：向所有事务参与者发送 commit 请求，所有的参与者进行提交操作。
- 如果任何一个参与者回应“no”， 协调器就会在阶段2向所有事务参与者发送中止请求。

这个过程可以类比为西式的婚礼： 神父会分别询问新娘与新郎是否与愿意与对方结婚，如果神父收到两个人"I DO" 的回答，就会正式宣布两人结为夫妇（ 相当于事务提交）。如果任何一个人没有说"yes"，婚礼就会被中止。

# 为什么2PC可以保证原子性？
上面的解释并不能很清楚的说明为什么2PC可以保证原子性。 如果commit 请求因为网络原因而丢失了会怎样呢？ 

为了理解为什么2PC可以保证原子性，需要进深入的解析2PC的执行过程：
1. 当程序需要开启一个分布式事务时，它从协调器获取一个全局唯一的事务ID（GTID）
2. 程序在每一个事务参与者的节点上开启一个本地事务，并与GTID相关联。所有的读写都发生在这些本地事务中。在这个阶段发生任何错误（节点挂掉，请求超时等），协调器或参与者都可以中止事务。
3. 当应用程序准备提交事务时， 协调器会向所有参与者发送该GTID事务的prepare请求。如果请求失败或超时，协调器就会所有参与者发送中止该GTID事务的请求。
4. 参与收到prepare 请求时， 就会去确认是否可以成功地提交事务（数据写盘，数据冲突，一致性约束等）。如果响应"yes"，就意味着在任何情况下都必须成功地提交该事务。 相当于参与者放弃了中止事务的权力，保证必须成功提交事务。
5. 当协调器收到所有事务参与者的prepare响应后，它需要做出一个明确的决定：提交还是中止事务（只能全部事务参与者投票为提交时才提交）。协调者随后必须将判定结果写入磁盘上的事务日志中，以便万一协调器挂掉后可以追溯出判定结果，这个叫做检查点。
6. 一旦判定结果写入了磁盘，协调器就会将结果发送给所有的事务参与者。 如果发送失败或超时，协调器必须一直重试直到成功。没有其它的选择。如果判定结果为提交，无论重试多少次，所有事务参与者都必须成功提交事务。如果有某个参与者的节点在提交事务前挂掉了，在节点恢复后依然要保证能提交事务。

这个协议里有两个重要的‘不能回头’的点：
- 参与者在prepare 阶段投了yes， 就必须保证在任何情况下都能提交事务（即使最终协调器做出中止决定）
- 协调器在阶段2作出事务判定后，判定结果是不能更改的。
这两点保证了2PC的原子性。

回到婚礼的比喻， 在你说“I DO” 前，都有拒绝的权力。一旦说了“I DO”,就不能反悔。如果在说完“I DO”之后因走神而没有听到神父宣布的消息，并不改变事务已经提交的事实。在你回过神后可以通过询问神父来确认是否已经结为夫妇，或者神父会再告诉你一遍（在走神期间，神父会一直向你发送结果）


# 协调器挂了怎么办？

上面讨论了2PC在参与者或者网络失败的情况下的情况：如果prepare请求失败或超时，协调器中止事务；如果阶段2的提交或中止请求失败，协调器会一直重试。 但如果协调器挂了怎么办呢？

如果协调器在发送prepare请求前挂掉，参与者可以安全地中止事务。一旦参与者收到了prepare请求并做出"yes"的响应，它就不能再直接地中止事务，必须等待协调器的通知：提交或中止。如果协调器或网络在这个时候挂了，参与者除了等待，什么也不能做。这种状况下参与者的事务叫存疑或不确定状态。


如下图所示，协调器最终决定了提交事务，DB2也收到了提交事务的请求。但协调器却在向DB1发送提交请求前挂掉了~这时DB1就不知道是应该提交事务还是中止事务了。这里也不能使用超时机制：如果超时后DB1直接中止了事务的，就会和DB2处于不一致的状态。同样，直接提交也不是一个安全的操作，因为其它的事务参与者可能是中止一事务。

![commit阶段Coordinator crash示意图](https://raw.githubusercontent.com/ihanyong/ihanyong.github.io/master/img/system/coordinatorCrashWhenCommit.png)

2PC中，应对这种状况的唯一方案就是尽快恢复协调器。这也是为什么协调器在阶段2发送判定结果前需要将判定结果存到磁盘上的事务日志上的原因。当协调器恢复之后可以通过读取事务日志来判定一个事务是应该提交的还是中止的。任何事务在协调器的事务日志中没有commit状态的记录，就一定是中止的。 从这个角度看，2PC是将多节点的分布式事务通过检查点机制转化为了协调器上的单节点事务。


