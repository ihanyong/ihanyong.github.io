---
layout: post
title:  "MySQL 设计中的陷阱"
date:   2018-05-22 22:30:00 +0800
categories: tech
---
今天提交一个DDL的时候， DBA建议把新增字段设置为 **NOT NULL**，突然意识到数据库的一些最佳实践并没有坚持用起来。 今天刚好做个总结， 稍微盘点一下MySQL设计中的一些实践和陷阱。

## MySQL schema 设计中的陷阱
#### 太多的列
mysql 需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据， 然后在服务器层将缓冲内容解码成各个列， 这个转换操作的代价是非常高的。转换的代价依赖于列的数量， 如果设计了非常宽的表（数千个列？）， 但实际使用的只有一小部分， 这时的代价就非常的高。 

#### 太多的关联
**实体-属性-值（EAV）** 是一个常见的糟糕设计模式， 尤其是的mysql下。 Mysql每个关联最多有61张表， 面EAV数据库需要许多自关联。 不少EAV最后走过了这个限制。在少于61张表的情况下， 解析和优化查询的代价也是一个问题。一个粗略的经验法则是： 希望查询执行得快速且并发性好， 单个查询最好在12个表以内做关联。

#### 全能的枚举
注意防止过度使用枚举（ENUM）。 下面是一个常见的例子：
```
create table foo (
    country enum('1, '2', '3')
);
```
这种设计很是凌乱。 这么使用枚也许在任何一个支持枚举的数据库都是一个有问题的设计方案， 这里应该用整数作为外键，关联到字典表来查找具体值。 在mysql中， 为枚举增加一下新的枚举值时要做一次 **ALTER TABLE** 操作。 在5.0以前，  **ALTER TABLE** 是一个阻塞操作； 即使是在新版本中，也是要 **ALTER TABLE** 。

#### 变相的枚举
枚举（ENUM）与集合（SET）容易混淆。枚举允许在列中存储一组定义值中的单个值， 集合列则允许在列中存储一组定义值中的一个值或多个值。

#### 非此发明的NULL
尽量避免使用NULL， 查询中包含可为NULL的列， 对mysql来说更难优化， 因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL列会使用更多 的存储空间，在mysql里也需要特殊处理。可为NULL列被索引时，每个索引记录会需要一个额外的字节。

需要存储一个“空值”到表中时， 可以使用0、某个特殊值，或者空字符串作为代替。

但遵循这个原则也不要走极端。 确实表示未知值时也不要害怕使用NULL， 在一些场景中， 使用NULL可能会比某个神奇常数更好。从特定类型的值域中选一个不可能的值，例如用-1代表一个未知的整数，可能导致代码复杂很多， 并容易引入BUG， 还可能让事情变得一团糟。 处理NULL确实不易， 但有时会比它的替代方案更好。


>《高性能MySQL》

