---
layout: post
title:  "【日常学习笔记】Flink生产准备checklist"
date:   2019-04-23 14:00:00 +0800
tags:
        - 流处理
        - Flink
---

本文为一些重要的配置提供了一个checklist，如果计划将Flink应用到生产环境， 需要仔细的考虑这些配置。
对于多数的配置Flink提供了开箱即用的默认配置，以方便使用和验证Flink。 对于多数的用户与场景，这些默认配置对于开发来说是个不错的起点， 对于大多数一次性的job来说也是完全满足需要的了。

然而， 一旦将Flink应用引入到生产环境，需求通常是不断增加的。 可能需要方便地扩展job, 升级job或升级新的Flink版本。


# 为算子显示地设置最大并行度
最大并行度的配置是在Flink1.2引入的，并深刻地影响着Flink作业的可扩展性。 这个配置可以设置粒度可以是一个作业或一个算子，决定了一个算子的最大并行度。
在作业启动之后，就没有办法去修改这个配置了。除非是完全地重新启动一个新的作业（新的状态，不能从之前的检查点或保存点启动）。 即使以后Flink可能会提供一些修改保存点最大并行度的方法， 也应该假设这个操作对于大体量的状态来说是一个长耗时的操作（避免）。 那对于当前为什么不默认设置一个非常大的值呢？ 这是因为高并行度会影响应用的性能和状态的大小。 一般来说， 需要选择一个足够大的值来满足未来的扩展需求，但又要尽量的小来保证性能。
特别是，最大并行度高于128通常会导致keyed后端的状态快照变大。

最大并行度必须满足下面的条件：
> 0 < parallelism <= max parallelism <= 2^15

可以通过setMaxParallelism(int maxparallelism)来设置最大并行度。 默认情况下，Flink作业首次启动时通过一个并行度的函数来计算最大并行度：

- 128 : for all parallelism <= 128.
- MIN(nextPowerOfTwo(parallelism + (parallelism / 2)), 2^15) : for all parallelism > 128.


# 为算子设置UUIDs

用户需要为算子设置一个uids。 算子的uids对于Flink的算子状态到算子的映射非常重要，反过来对于保存点也非常重要。

默认情况下，算子uids是通过遍历JogGraph和散列某些运算符属性生成的。虽然从用户的角度来看这是一种方便的方式，但也是非常脆弱的，因为对JobGraph的修改（例如调整算子顺序）将导致新的UUID。为了建立一个稳定的映射，我们需要用户通过setUid(String uid)方法提供稳定的算子uids。

# 状态后台的选择（强烈建议使用RocksDB）

现在， Flink只能使用相同的状态后端来保存恢复保存点，即如果我们使用内存状态后端生成的保存点，后面我们就不能把作业的状态后端改为RocksDB状态后端并恢复保存点。 尽管我们计划尽快的实现不同的状态后端的互通，但当前还是没有实现的。 这样在我们将Flink应用于生产环境前就必须仔细的考虑需要使用哪个状态后端。

一般我们建议使用RocksDB状态后端，因为当前这是唯一可以支持大体量状态（如状态大小超过了可用内存）和异步快照的后端。 根据经验，异步快照功能对于大体量状态来说是非常重要的。因为这样不会阻塞算子操作，Flink在生成快照时不需要挂起流处理。 但是比起基于内存等其它后端, RocksDB性能会差一些。 如果能确保状态大小不会超出内存，并且不在乎写快照时对流处理的阻塞，可以考虑不使用RocksDB后端。 然而当前在生产环境中是强烈建议使用RocksDB。


# 为JobManaager 配置高可用（HA）

JobManager 用来协调所有的Flink发布。 负责调度和资源管理。
默认情况下， 每个Flink集群只有一个JobManager实例。这很容易造成单点故障（SPOF）：如果JobManager崩溃了，就不能再提交新的作业，且运行中的作业也会失败。

通过配置JobManager高可用， 可以将JobManager从故障中恢复，从而消除单点故障。在生产环境中强烈配置高可用。


# FQAs
### Question1: 
Q: 
A: 